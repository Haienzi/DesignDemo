# DesignDemo
设计模式学习与实践

## 六大原则
- 单一职责原则(一个类和方法只做一件事)
- 里氏替换原则(多态，子类可扩展父类)
- 依赖倒置原则(面向接口编程)
- 接口隔离
- 迪米特原则
- 开闭原则

## 创建型模式

### 工厂方法模式
- 在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型, 定义一个创建对象的接口，让子类自己决定实例化哪一个工厂类，使创建过程延迟到子类进行,考虑的是一类产品的生产.
- Demo模仿首页卡片的初始化。通过MainPageCellFactory来按照数据类型初始化不同的卡片，在不关心内部具体实现的情况下可以通过MainPageCell按照统一的方式进行修改，每一种卡片的具体处理在本类中进行实现，容易扩展

### 抽象工厂模式
- 为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品
- 抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂和抽象产品打交道
- 单一职责，开闭原则、解耦
- 抽象工厂方法模式：工厂和产品都是抽象的，每个具体工厂负责一类产品的实现，可以随时切换到另一组工厂和产品。假设A和B的视图都包括顶部、中腰，通过ViewAbstractFactory来统一定义创建顶部视图和中腰视图的接口，MainViewFactoryA和MainViewFactoryB作为具体的工厂来创建顶部和中腰的视图组合，可以根据数据实现视图组合的切换，满足单一职责原则。

### 单例模式
- 保证在程序运行过程中一个类只有一个实例（即使多线程访问），并需要提供一个全局访问此实例的点。使用场合，共享的资源只需要初始化一次，让这个类创建出来的对象永远只有一个。
- 单例模式主要解决的是：一个全局使用的类频繁的创建和消费，从而提升代码的性能.

### 建造者模式
- 主要思想是将多个简单对象通过一步步组装构建出一个复杂对象的过程。工厂模式关注的是一个产品整体，不需要关注各部分是如何构建出来的，建造者模式则关注产品组成部分的创建过程，通过不同的组件，不同设置可以产生不同的复杂对象。
- Demo使用建造者模式简单模拟弹出视图的构建。弹出视图MyPopupView包括顶部标题，中间视图，底部按钮（确定和取消按钮，先创建者排列在前，也可以只创建一个）。使用者通过调用建造者PopupViewBuilder对象的装配方法来设置弹出视图的标题，中间内容视图，底部按钮点击事件，按钮标题，视图圆角等属性。
- 建造者模式和工厂模式的区别是：
  - 工厂模式关注的是一个产品整体，生产出的产品具有相似的功能和结构，不需要关注产品的各部分是如何建造出来的
  - 建造者模式关注的是产品的组成部分的创建过程，通过不同的部件，不同装配产生不同的复杂对象，产品类调用顺序不同可能产生不同的作用

## 结构型模式
### 代理模式
- 定义：为其他对象提供一种代理来控制对这个对象的访问，组成部分包括协议(用来指定代理双方要做什么事情)，代理(根据指定的协议，完成协议规定的事情)，委托(根据指定的协议，指定代理去完成事情).
- Demo实践了两种应用场景，第一种通过代理设计模式的思想，将UITableView的数据操作交给一个代理对象去实现，减少使用时控制器的代码量。另外实现一对多的代理模式（使用通知实现时需要移除通知），使用DelegateManager管理delegate数组，截获方法数组遍历调用相应方法，当委托方调用方法时，所有注册了协议的类都会接受到协议的方法回调。ATestViewController和BTestViewController都实现了TestViewDelegate协议，并将代理对象设置为DelegateManage，ATestView作为委托者调用相应方法后A和B都将接受到方法回调。

### 适配器模式
- 主要思想：把原本不兼容的接口，通过适配修改到统一，做不同接口的兼容。使得原本由于接口不兼容而不能一起工作的类可以一起工作。
- 实现方式：
  - 类适配器（使用继承)
    - 定义现在客户端将要使用的协议
    - 使用适配器类Adapter实现这个协议
    - 适配器类继承自被适配者Adaptee（与现有客户端不兼容的类）
  - 对象适配器（使用组合):Adapter不继承Adaptee，而是使用对象组合：Adapter持有一个Adaptee的实例引用
    - 代理模式属于对象适配器
- 对象适配器和类适配器的区别：
  - 类适配器：
    - 只针对单一的具体的Adaptee类，把Adaptee适配到Target
    - 通过子类的形式适配，易于重载Adaptee的行为
    - 不需要额外的指针指向Adaptee
  - 对象适配器
    - 通过持有对象的方式，可以适配多个adaptee
    - 难以重载Adaptee的行为，需要借助对象实现
    - 需要额外的指针间接访问Adaptee适配其行为
- 使用场景
  - 已有类的接口与需求不匹配
  - 面对遗留代码，期望项目统一使用新特性同时兼容已有类
  - 扩展新功能，方便接入新的第三方库
- 应用示例：iOS中一般通过协议（Target为接口）来实现适配器。例如UITableViewDelegate和UITableViewDataSource,将原本不能为UITableView提供数据操作事件的其他类
（UIView,UIViewController等）包装成数据源代理，即为类适配器的应用。

### 桥接模式
- 主要思想：
  - 将抽象部分与实现部分分离，把多种可匹配的使用进行组合。
  - 抽象层定义了供客户端使用的上层的抽象接口，使用对象的组合关系，解耦抽象和实现之间固有的绑定关系，使抽象和实现可以沿着各自的维度变化(子类化)，实现在多个维度上的独立变化
- 实现：存在两个base类，BaseA和BaseB，每个都有很多不同的子类，BaseA持有BaseB的一个实例，BaseA的子类调用方法时，会调用持有的BaseB类的实例方法（在使用时，BaseB类的实例被赋值一个初始化了的实现子类）
- 使用场景：
- 应用示例：


### 组合模式
- 主要思想：
  - 将抽象部分与实现部分分离，把多种可匹配的使用进行组合。
  - 抽象层定义了供客户端使用的上层的抽象接口，使用对象的组合关系，解耦抽象和实现之间固有的绑定关系，使抽象和实现可以沿着各自的维度变化(子类化)，实现在多个维度上的独立变化
- 实现：存在两个base类，BaseA和BaseB，每个都有很多不同的子类，BaseA持有BaseB的一个实例，BaseA的子类调用方法时，会调用持有的BaseB类的实例方法（在使用时，BaseB类的实例被赋值一个初始化了的实现子类）
- 使用场景：
- 应用示例：

## 行为模式
### 观察者模式
- 当对象间存在一对多关系时，则使用观察者模式。当一个对象被修改时，会自动通知依赖它的对象。观察者模式中有两个主要角色Subject和观察者Observer
- 观察者模式通常需要在Subject类中维护一个Observer观察者数组，只要Subject类中有一些事件变化就可以通知所有的观察者并执行相应逻辑
- 使用场景
  - 一个对象的改变将导致其他一个或多个对象发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度
  - 一个对象必须通知其他对象，而并不知道这些对象是谁
  - 为一些关键节点（比如View的生命周期）定义通知，当这些关键节点产生变化时通知对应的观察者，相比代理可以降低对象之间的耦合度
