# DesignDemo
设计模式学习与实践

## 六大原则
- 单一职责原则(一个类和方法只做一件事)
- 里氏替换原则(多态，子类可扩展父类)
- 依赖倒置原则
- 接口隔离
- 迪米特原则
- 开闭原则

## 创建型模式

### 工厂方法模式
- 在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型, 定义一个创建对象的接口，让子类自己决定实例化哪一个工厂类，使创建过程延迟到子类进行,考虑的是一类产品的生产.
- Demo模仿首页卡片的初始化。通过MainPageCellFactory来按照数据类型初始化不同的卡片，在不关心内部具体实现的情况下可以通过MainPageCell按照统一的方式进行修改，每一种卡片的具体处理在本类中进行实现，容易扩展


### 抽象工厂模式
- 为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品
- 抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂和抽象产品打交道
- 单一职责，开闭原则、解耦
- 抽象工厂方法模式：工厂和产品都是抽象的，每个具体工厂负责一类产品的实现，可以随时切换到另一组工厂和产品。假设A和B的视图都包括顶部、中腰，通过ViewAbstractFactory来统一定义创建顶部视图和中腰视图的接口，MainViewFactoryA和MainViewFactoryB作为具体的工厂来创建顶部和中腰的视图组合，可以根据数据实现视图组合的切换，满足单一职责原则。

### 单例模式
- 保证在程序运行过程中一个类只有一个实例（即使多线程访问），并需要提供一个全局访问此实例的点。使用场合，共享的资源只需要初始化一次，让这个类创建出来的对象永远只有一个。
- 单例模式主要解决的是：一个全局使用的类频繁的创建和消费，从而提升代码的性能.

### 建造者模式
- 主要思想是将多个简单对象通过一步步组装构建出一个复杂对象的过程。工厂模式关注的是一个产品整体，不需要关注各部分是如何构建出来的，建造者模式则关注产品组成部分的创建过程，通过不同的组件，不同设置可以产生不同的复杂对象。
- Demo使用建造者模式简单模拟弹出视图的构建。弹出视图MyPopupView包括顶部标题，中间视图，底部按钮（确定和取消按钮，先创建者排列在前，也可以只创建一个）。使用者通过调用建造者PopupViewBuilder对象的装配方法来设置弹出视图的标题，中间内容视图，底部按钮点击事件，按钮标题，视图圆角等属性。
- 建造者模式和工厂模式的区别是：
  - 工厂模式关注的是一个产品整体，生产出的产品具有相似的功能和结构，不需要关注产品的各部分是如何建造出来的
  - 建造者模式关注的是产品的组成部分的创建过程，通过不同的部件，不同装配产生不同的复杂对象，产品类调用顺序不同可能产生不同的作用

## 行为模式
### 观察者模式
- 当对象间存在一对多关系时，则使用观察者模式。当一个对象被修改时，会自动通知依赖它的对象。观察者模式中有两个主要角色Subject和观察者Observer
- 观察者模式通常需要在Subject类中维护一个Observer观察者数组，只要Subject类中有一些事件变化就可以通知所有的观察者并执行相应逻辑
- 使用场景
  - 一个对象的改变将导致其他一个或多个对象发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度
  - 一个对象必须通知其他对象，而并不知道这些对象是谁
  - 为一些关键节点（比如View的生命周期）定义通知，当这些关键节点产生变化时通知对应的观察者，相比代理可以降低对象之间的耦合度

## 结构型模式
### 代理模式
- 定义：为其他对象提供一种代理来控制对这个对象的访问，组成部分包括协议(用来指定代理双方要做什么事情)，代理(根据指定的协议，完成协议规定的事情)，委托(根据指定的协议，指定代理去完成事情).
- Demo实践了两种应用场景，第一种通过代理设计模式的思想，将UITableView的数据操作交给一个代理对象去实现，减少使用时控制器的代码量。另外实现一对多的代理模式（使用通知实现时需要移除通知），使用DelegateManager管理delegate数组，截获方法数组遍历调用相应方法，当委托方调用方法时，所有注册了协议的类都会接受到协议的方法回调。ATestViewController和BTestViewController都实现了TestViewDelegate协议，并将代理对象设置为DelegateManage，ATestView作为委托者调用相应方法后A和B都将接受到方法回调。
